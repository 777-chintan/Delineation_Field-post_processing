import os
import json
from skimage.draw import polygon
from shapely.geometry import Polygon,MultiPolygon
from shapely.geometry import Point
import numpy as np
from pathlib import Path
import cv2
from PIL import Image as pilimage
from PIL import ImagePath 
import matplotlib.pyplot as plt
from matplotlib.collections import PatchCollection
from descartes import PolygonPatch
import pandas as pd
from tqdm import tqdm

# directory path of input 
INPUT_DIR = '/home/chintu/Desktop/maskrcnn/maskrcnn_wth_tensorflow_object_detection_api/training_data/train/' 
IMAGE_DIR= os.path.join(INPUT_DIR,"images")
MACHINE_ANNO_PATH=os.path.join(INPUT_DIR,"machine_annotation.json")
USER_ANNO_PATH=os.path.join(INPUT_DIR,"annotation.json")
OUT_PATH= os.path.join(INPUT_DIR,"validation_output")

# get polygon points from polygon 
def get_polygon(all_points_x,all_points_y):
	if len(all_points_y)<=2:
		return None
	polygon=[]
	for i in range(len(all_points_x)):
		polygon.append((all_points_x[i],all_points_y[i]))
	polygon = np.asarray(polygon)
	return polygon

# get polygon point from rectanngle
def get_polygon_rect(x,y,width,height):
	polygon=[]
	polygon.append((x,y))
	polygon.append((x+width,y))
	polygon.append((x,y+height))
	polygon.append((x+width,y+height))
	polygon=np.asarray(polygon)
	return polygon

#get IOU between two polygons
def polygon_iou(pa, pb):
	"""Returns IOU of two polygon"""
	pa = Polygon(pa)
	pb = Polygon(pb)
	# If there is a single loop
	#return (pa.intersection(pb).area / pa.union(pb).area)*100
	if not(pa.is_valid):
		pa = pa.buffer(0)
	if not(pb.is_valid):
		pb = pb.buffer(0)
	# If there are multiple loops then it might throw an error
	x = pa.intersection(pb).area
	if x is None:
		x = 0
	return ((100 * x) / pa.union(pb).area)


def get_polygons_from_cocojson(inpath_json):
	"""
	input : coco json file generated by preprocessing script
	output : dict contains multipolygon in form of
			 { 'image_name': Multipolygon}
	"""
	data = json.load(open(inpath_json,"r"))
	
	image_ids = sorted(list(set([x['image_id'] for x in data['annotations']])))
	file_names = [x['file_name'] for x in data['images'] if x['id'] in image_ids]
	
	# Extract selected annotations per image.
	extracted_geometries = {}
	for image_id, file_name in zip(image_ids, file_names):
		annotations = [x for x in data['annotations'] if x['image_id'] == image_id]
		
		segments = [segment['segmentation'][0] for segment in annotations]  # format [x,y,x1,y1,...]

		# Create shapely Multipolygons from COCO format polygons.
		mp = [Polygon(np.array(segment).reshape((int(len(segment) / 2), 2))) for segment in segments]
		extracted_geometries[str(file_name)] = mp
	
	return extracted_geometries

def get_polygons_from_modeloutput_json(inpath_json):
	data = json.load(open(inpath_json,"r"))
	extracted_geometries = {}
	for key in data.keys():
		file_name=data[key]['filename']
		regions=data[key]['regions']
		mp=[Polygon(get_polygon(items['shape_attributes']['all_points_x'],items['shape_attributes']['all_points_y'])) for items in regions]
		extracted_geometries[str(file_name)]=mp
	return extracted_geometries


def export_json(polygons,image_name):
	final_object={}
	image_object={}
	image_object["filename"]=image_name
	regions=[]
	for _idx,poly in polygons.items():
		region={}
		all_points_x=poly[:,0].tolist()
		all_points_y=poly[:,1].tolist()
		polygon={}
		polygon["name"]="polygon"
		polygon["all_points_y"]=all_points_y
		polygon["all_points_x"]=all_points_x
		region["shape_attributes"]=polygon
		regions.append(region)
	image_object["regions"]=regions
	final_object[image_name]=image_object
	return final_object

def draw_polygon(user_polygons,name,img_path):
	
	#draws polygons into image and saves output into the val_output folder
	
	#img = np.asarray(pilimage.open(img_path))
	img = cv2.imread(img_path)
	#img1=img
	image_name=os.path.basename(img_path)
	image_name= image_name.replace(".jpg","")
	"""
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_0.jpg")))
	plt.close()

	#saving machine output
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	mp=MultiPolygon(machine_polygons)
	patches = [PolygonPatch(p, ec='blue', fc='red', alpha=0.3, lw=1, zorder=1) for p in mp]
	plt.gca().add_collection(PatchCollection(patches, match_original=True))

	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_1.jpg")))
	plt.close()
	"""
	#saving user output
	for polygon in user_polygons :
		points = np.array(polygon.exterior)
		contour = []
		for x,y in points:
			contour.append([x,y])
		contour= np.array(contour,dtype=np.int32)
		if(contour.size!=0):
			cv2.drawContours(img, [contour], -1, (0, 0, 0), 3)
	
	cv2.imwrite(os.path.join(OUT_PATH,image_name,str(name +".jpg")),img)
	#print(contours)
	'''
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	mp=MultiPolygon(user_polygons)
	patches = [PolygonPatch(p, ec='blue', fc='red', alpha=0.3, lw=1, zorder=1) for p in mp]
	plt.gca().add_collection(PatchCollection(patches, match_original=True))
	
	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_"+name +".jpg")))
	plt.close()
	'''
	return
"""
def draw_polygon(user_polygons,machine_polygons,img_path):
	
	#draws polygons into image and saves output into the val_output folder
	
	img = np.asarray(pilimage.open(img_path))
	#img1=img
	image_name=os.path.basename(img_path)
	image_name= image_name.replace(".jpg","")
	
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_0.jpg")))
	plt.close()

	#saving machine output
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	mp=MultiPolygon(machine_polygons)
	patches = [PolygonPatch(p, ec='blue', fc='red', alpha=0.3, lw=1, zorder=1) for p in mp]
	plt.gca().add_collection(PatchCollection(patches, match_original=True))

	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_1.jpg")))
	plt.close()
	
	#saving user output
	plt.figure(figsize=(5, 5))
	plt.axis('off')
	plt.imshow(img, interpolation='none')

	mp=MultiPolygon(user_polygons)
	patches = [PolygonPatch(p, ec='blue', fc='red', alpha=0.3, lw=1, zorder=1) for p in mp]
	plt.gca().add_collection(PatchCollection(patches, match_original=True))
	
	Path(OUT_PATH).mkdir(parents=True, exist_ok=True)
	plt.savefig(os.path.join(OUT_PATH,str(image_name+ "_2.jpg")))
	plt.close()
	return
	
"""

user_polygons=get_polygons_from_cocojson(USER_ANNO_PATH)
machine_polygons=get_polygons_from_modeloutput_json(MACHINE_ANNO_PATH)
MACHINE_POLY=machine_polygons
USER_POLY=user_polygons


"""
print("Saving image comparison ")
for key in tqdm(machine_polygons.keys()):
	img_path = os.path.join(IMAGE_DIR,key)
	if os.path.exists(img_path):
	   draw_polygon(user_polygons[key],machine_polygons[key],img_path)
"""

final_json={}
numerous=[]
print("comapring machine and user outputs")
for key in tqdm(machine_polygons.keys()):
	main=[]
	mpoly=machine_polygons[key]
	upoly=user_polygons[key]

	img_path = os.path.join(IMAGE_DIR,key)
	img = cv2.imread(img_path)
	if os.path.exists(img_path):
		Path(os.path.join(OUT_PATH,os.path.basename(img_path).replace(".jpg",""))).mkdir(parents=True, exist_ok=True)
		cv2.imwrite(os.path.join(OUT_PATH,os.path.basename(img_path).replace(".jpg",""),os.path.basename(img_path)),img)
		cv2.imwrite(os.path.join(OUT_PATH,os.path.basename(img_path)),img)
		draw_polygon(mpoly,"detections",img_path)
		draw_polygon(upoly,"groundtruth",img_path)

	#print(len(mpoly))
	false_positive=[]
	true_positive=[]
	false_nagetive=[]
	for poly1 in upoly:
		max_iou=0
		max_polygon=[]
		for poly2 in mpoly:
			iou=polygon_iou(poly1,poly2)
			if iou>=50.00 and max_iou<iou:
				max_iou=iou
				max_polygon=poly2
		if max_iou >= 50.00:
			true_positive.append(max_polygon)
			#upoly.remove(poly1)
			mpoly.remove(max_polygon)


	false_positive = mpoly
	#false_nagetive = upoly
	if os.path.exists(img_path):
	   draw_polygon(true_positive,"TP",img_path)
	   draw_polygon(false_positive,"FP",img_path)
	   #draw_polygon(false_nagetive,"FN",img_path)
	
	values={
		'TP': len(true_positive),
		'TN': 0,
		'FP': len(false_positive),
		#'FN': len(false_nagetive)
		'FN': len(upoly)-len(true_positive),
	}
	#values['TPR'] = values['TP']/(values['TP']+values['FN'])
	values['Precision']=values['TP']/(values['TP']+values['FP'])
	values['Recall']=values['TP']/(values['TP']+values['FN'])
	values['Accuracy']=values['TP']/(values['TP']+values['FN']+values['FP'])
	main.append(key)
	#main.append(values['TPR'])
	#main.append(values['TN'])
	#main.append(values['FP'])
	#main.append(values['FN'])
	main.append(values['Precision'])
	main.append(values['Recall'])
	main.append(values['Accuracy'])
	numerous.append(main)
	final_json[key]=values

OUT_JSON=os.path.join(OUT_PATH,"json")
Path(OUT_JSON).mkdir(parents=True, exist_ok=True)

fp = open(OUT_JSON + '/info.json', "w")
print("Writing json file")
fp.write(json.dumps(final_json))
fp.close()

df = pd.DataFrame(numerous, columns = ['Image name', 'Precision', 'Recall', 'Accuracy'])
print("Writing CSV file")
df.to_csv(os.path.join(OUT_JSON,"info.csv"), index = None)
